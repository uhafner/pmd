<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="Metric"
         xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd">

    <description>
        Rules that produce metrics.
    </description>

    <rule name="NumberOfAccessors"
          language="java"
          message="The {0} ''{1}'' has {2} accessors"
          since="7.8.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.NumberOfAccessorsRule">
        <description><![CDATA[
            Number of accessor methods in a class. Accessor methods are getters and setters.
        ]]></description>
        <priority>3</priority>
    </rule>

    <rule name="WeightOfClass"
          language="java"
          message="The {0} ''{1}'' has weight of {2}"
          since="7.8.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.WeightOfClassRule">
        <description><![CDATA[
            Number of “functional” public methods divided by the total number of public methods.
            Our definition of “functional method” excludes constructors, getters, and setters.

            The value is a double between 0 and 1.

            This metric tries to quantify whether the measured class’ interface
            reveals more data than behaviour. Low values (less than 30%) indicate
            that the class reveals much more data than behaviour, which is a
            sign of poor encapsulation.
        ]]></description>
        <priority>3</priority>
    </rule>

    <rule name="WeightedMethodCount"
          language="java"
          message="The {0} ''{1}'' has a weighted methods count of {2}"
          since="7.8.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.WeightedMethodCountRule">
        <description><![CDATA[
            Sum of the statistical complexity of the operations in the class.
            We use the cyclomatic complexity to quantify the complexity of an operation.

            WMC uses the same options as CYCLO, which are provided to CYCLO when computing it ({@link CycloOption}).
        ]]></description>
        <priority>3</priority>
    </rule>

    <rule name="Cohesion"
          language="java"
          message="The {0} ''{1}'' has a cohesion of {2}"
          since="7.8.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.CohesionRule">
        <description><![CDATA[
      The relative number of method pairs of a class that access in common
      at least one attribute of the measured class. TCC only counts direct
      attribute accesses, that is, only those attributes that are accessed
      in the body of the method.

      The value is a double between 0 and 1.

      TCC is taken to be a reliable cohesion metric for a class.
      High values (&gt;70%) indicate a class with one basic function,
      which is hard to break into subcomponents. On the other hand, low
      values (&lt;50%) may indicate that the class tries to do too much
      and defines several unrelated services, which is undesirable.
        ]]></description>
        <priority>3</priority>
    </rule>

    <rule name="Loc"
          language="java"
          message="The {0} ''{1}'' has {2} lines of code"
          since="7.8.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.LocRule">
        <description><![CDATA[
            Simply counts the number of lines of code the operation or class
      takes up in the source. This metric doesn’t discount comments or blank lines.
      See {@link #NCSS} for a less biased metric.
        ]]></description>
        <priority>3</priority>
    </rule>

    <rule name="FanOut"
          language="java"
          message="The {0} ''{1}'' has a fan out of {2}"
          since="7.8.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.FanOutRule">
        <description><![CDATA[
            This counts the number of other classes a given class or operation
      relies on. Classes from the package {@code java.lang} are ignored
      by default (can be changed via options). Also primitives are not
      included into the count.
        ]]></description>
        <priority>3</priority>
        <example><![CDATA[
      import java.util.*;
      import java.io.IOException;

      public class Foo { // total 8
          public Set set = new HashSet(); // +2
          public Map map = new HashMap(); // +2
          public String string = ""; // from java.lang -> does not count by default
          public Double number = 0.0; // from java.lang -> does not count by default
          public int[] intArray = new int[3]; // primitive -> does not count

          \@Deprecated // from java.lang -> does not count by default
          public void foo(List list) throws Exception { // +1 (Exception is from java.lang)
              throw new IOException(); // +1
          }

          public int getMapSize() {
              return map.size(); // +1 because it uses the Class from the 'map' field
          }
      }
      }
]]>
        </example>
    </rule>

    <rule name="AccessToForeignData"
          language="java"
          message="The {0} ''{1}'' has {2} usages of foreign attributes, both directly and through accessors."
          since="7.8.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.AccessToForeignDataMetric">
        <description><![CDATA[
    Number of usages of foreign attributes, both directly and through accessors.
      "Foreign" hier means "not belonging to {@code this}", although field accesses
      to fields declared in the enclosing class are not considered foreign.

      High values of ATFD (&gt; 3 for an operation) may suggest that the
      class or operation breaks encapsulation by relying on the internal
      representation of the classes it uses instead of the services they provide.
        ]]></description>
        <priority>3</priority>
    </rule>

    <rule name="CognitiveComplexity"
          language="java"
          message="The {0} ''{1}'' has a cognitive complexity of {2}"
          since="7.5.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.CognitiveComplexityRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#cognitivecomplexity">
        <description><![CDATA[
            Methods that are highly complex are difficult to read and more costly to maintain. If you include too much decisional
            logic within a single method, you make its behavior hard to understand and more difficult to modify.

            Cognitive complexity is a measure of how difficult it is for humans to read and understand a method. Code that contains
            a break in the control flow is more complex, whereas the use of language shorthands doesn't increase the level of
            complexity. Nested control flows can make a method more difficult to understand, with each additional nesting of the
            control flow leading to an increase in cognitive complexity.

            Information about Cognitive complexity can be found in the original paper here:
            <https://www.sonarsource.com/docs/CognitiveComplexity.pdf>
        ]]></description>
        <priority>3</priority>
        <example>
            <![CDATA[
public class Foo {
  // Has a cognitive complexity of 0
  public void createAccount() {
    Account account = new Account("PMD");
    // save account
  }

  // Has a cognitive complexity of 1
  public Boolean setPhoneNumberIfNotExisting(Account a, String phone) {
    if (a.phone == null) {                          // +1
      a.phone = phone;
      return true;
    }

    return false;
  }

  // Has a cognitive complexity of 4
  public void updateContacts(List<Contact> contacts) {
    List<Contact> contactsToUpdate = new ArrayList<Contact>();

    for (Contact contact : contacts) {                           // +1
      if (contact.department.equals("Finance")) {                // +2 (nesting = 1)
        contact.title = "Finance Specialist";
        contactsToUpdate.add(contact);
      } else if (contact.department.equals("Sales")) {           // +1
        contact.title = "Sales Specialist";
        contactsToUpdate.add(contact);
      }
    }
    // save contacts
  }
}
]]>
        </example>
    </rule>

    <rule name="CyclomaticComplexity"
          language="java"
          message="The {0} ''{1}'' has a cyclomatic complexity of {2}."
          since="7.5.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.CyclomaticComplexityRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#cyclomaticcomplexity">
        <description>
            The complexity of methods directly affects maintenance costs and readability. Concentrating too much
            decisional logic
            in a single method makes its behaviour hard to read and change.

            Cyclomatic complexity assesses the complexity of a method by counting the number of decision points in a
            method,
            plus one for the method entry. Decision points are places where the control flow jumps to another place in
            the
            program. As such, they include all control flow statements, such as `if`, `while`, `for`, and `case`. For
            more
            details on the calculation, see the documentation {% jdoc java::lang.java.metrics.JavaMetrics#CYCLO %}.

            Generally, numbers ranging from 1-4 denote low complexity, 5-7 denote moderate complexity, 8-10 denote
            high complexity, and 11+ is very high complexity.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
class Foo {
  void baseCyclo() {                // Cyclo = 1
    highCyclo();
  }

  void highCyclo() {                // Cyclo = 10: reported!
    int x = 0, y = 2;
    boolean a = false, b = true;

    if (a && (y == 1 ? b : true)) { // +3
      if (y == x) {                 // +1
        while (true) {              // +1
          if (x++ < 20) {           // +1
            break;                  // +1
          }
        }
      } else if (y == t && !d) {    // +2
        x = a ? y : x;              // +1
      } else {
        x = 2;
      }
    }
  }
}
]]>
        </example>
    </rule>

    <rule name="NPathComplexity"
          language="java"
          since="7.5.0"
          message="The {0} ''{1}'' has an NPath complexity of {2}"
          class="net.sourceforge.pmd.lang.java.rule.metric.NPathComplexityRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#npathcomplexity">
        <description>
            The NPath complexity of a method is the number of acyclic execution paths through that method.
            While cyclomatic complexity counts the number of decision points in a method, NPath counts the
            number of
            full paths from the beginning to the end of the block of the method. That metric grows
            exponentially, as
            it multiplies the complexity of statements in the same block. For more details on the
            calculation, see the
            documentation {% jdoc java::lang.java.metrics.JavaMetrics#NPATH %}.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
public class Foo {
  public static void bar() { // Ncss = 252: reported!
    boolean a, b = true;
    try { // 2 * 2 + 2 = 6
      if (true) { // 2
        List buz = new ArrayList();
      }

      for(int i = 0; i < 19; i++) { // * 2
        List buz = new ArrayList();
      }
    } catch(Exception e) {
      if (true) { // 2
        e.printStackTrace();
      }
    }

    while (j++ < 20) { //  * 2
      List buz = new ArrayList();
    }

    switch(j) { // * 7
      case 1:
      case 2: break;
      case 3: j = 5; break;
      case 4: if (b && a) { bar(); } break;
      default: break;
    }

    do { // * 3
        List buz = new ArrayList();
    } while (a && j++ < 30);
  }
}
 ]]>
        </example>
    </rule>
    <rule name="NcssCount"
          language="java"
          message="The {0} ''{1}'' has a NCSS line count of {2}"
          since="7.5.0"
          class="net.sourceforge.pmd.lang.java.rule.metric.NcssRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_design.html#ncsscount">
        <description>
            This rule uses the NCSS (Non-Commenting Source Statements) metric to determine the number of
            lines
            of code in a class, method or constructor. NCSS ignores comments, blank lines, and only counts
            actual
            statements. For more details on the calculation, see the documentation
            {% jdoc java::lang.java.metrics.JavaMetrics#NCSS %}.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
import java.util.Collections;       // +0
import java.io.IOException;         // +0

class Foo {                         // +1, total Ncss = 12

  public void bigMethod()           // +1
      throws IOException {
    int x = 0, y = 2;               // +1
    boolean a = false, b = true;    // +1

    if (a || b) {                   // +1
      try {                         // +1
        do {                        // +1
          x += 2;                   // +1
        } while (x < 12);

        System.exit(0);             // +1
      } catch (IOException ioe) {   // +1
        throw new PatheticFailException(ioe); // +1
      }
    } else {
      assert false;                 // +1
    }
  }
}
]]>
        </example>
    </rule>
</ruleset>
